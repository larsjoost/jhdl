#include <cassert>
#include <algorithm>
#include <string>

#include "parameters.hpp"
#include "name_converter.hpp"

namespace generator {

  void parameters::FileContainer::flush(bool verbose) {
    std::ofstream header_file;
    std::ofstream implementation_file;
    std::string header_file_name = replaceFileExtension(file_name, ".hpp");
    header_file.open(header_file_name);
    implementation_file.open(replaceFileExtension(file_name, ".cpp"));
    content.implementation_top.push_front("#include \"" + header_file_name + "\"");
    std::string header_def = file_name + "_HPP";
    std::replace(header_def.begin(), header_def.end(), '.', '_');
    header_def = NameConverter::toUpper(header_def);
    header_file << "#ifndef " << header_def << std::endl;
    header_file << "#define " << header_def << std::endl;
    content.include.push_front("#include <string.h>");
    content.include.push_front("#include <systemc.h>");
    content.include.push_front("#include <vhdl.h>");
    content.namespace_start = "namespace " + NameConverter::toUpper(library) + " {";
    content.namespace_end = "} // namespace " + NameConverter::toUpper(library) + " end ";
    if (verbose) {
      header_file << "// Autogenerated from source " << file_name << std::endl;
      implementation_file << "// Autogenerated from source " << file_name << std::endl;
    }
    content.flush(header_file, implementation_file, 0, verbose);
    header_file << "#endif" << std::endl;
    header_file.close();
    implementation_file.close();
  }

  parameters::ClassContainer* parameters::FileContainer::getCurrentClassContainer() {
    debug.functionStart("getCurrentClassContainer");
    ClassContainer* a = NULL;
    auto class_container_callback =
      [&](ClassContainer& class_container, int hierarchy) {
	a = &class_container;
      };
    traverseClassContainerHierarchy(class_container_callback);
    debug.functionEnd("getCurrentClassContainer");
    return a;
  }
  
}
