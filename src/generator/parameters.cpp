#include <cassert>

#include "parameters.hpp"

namespace generator {

  std::string parameters::replaceFileExtension(std::string filename, std::string extension) {
    return baseName(filename) + extension;
  }

  std::string parameters::baseName(std::string filename) {
    size_t lastdot = filename.find_last_of(".");
    if (lastdot == std::string::npos) return filename;
    return filename.substr(0, lastdot);
  }
  
  void parameters::open(std::string filename, std::string library) {
    debug.functionStart("open(filename = " + filename + ")");
    info_writer.Open(replaceFileExtension(filename, ".i"));
    file_container.file_name = filename;
    file_container.library = library;
    debug.functionEnd("open");
  }
  
  void parameters::close() {
    debug.functionStart("close");
    file_container.flush(true);
    info_writer.Close();
    debug.functionEnd("close");
  }
  
  void parameters::FileContainer::flush(bool verbose) {
    std::ofstream header_file;
    std::ofstream implementation_file;
    std::string header_file_name = replaceFileExtension(file_name, ".hpp");
    header_file.open(header_file_name);
    implementation_file.open(replaceFileExtension(file_name, ".cpp"));
    content.implementation_top.push_front("#include \"" + header_file_name + "\"");
    std::string header_def = file_name;
    header_file << "#ifndef " << header_def << std::endl;
    header_file << "#define " << header_def << std::endl;
    header_file << "#include <string.h>"  << std::endl;
    header_file << "#include <systemc.h>" << std::endl;
    header_file << "#include <vhdl.h>" << std::endl;
    header_file << "namespace vhdl { namespace " << library << "{" << std::endl;
    implementation_file << "namespace vhdl { namespace " << library << "{" << std::endl;
    if (verbose) {
      header_file << "// Autogenerated from source " << file_name << std::endl;
      implementation_file << "// Autogenerated from source " << file_name << std::endl;
    }
    content.flush(header_file, implementation_file, 0, verbose);
    header_file << "}}" << std::endl;
    implementation_file << "}}" << std::endl;
    header_file << "#endif" << std::endl;
    header_file.close();
    implementation_file.close();
  }

  void parameters::println(std::ostream& handle, std::string text) {
    handle << text << std::endl;
  }
  
  void parameters::print(std::ostream& handle, std::string text) {
    handle << text;
  }
  
  void parameters::println(std::ostream& handle, std::list<std::string>& lines) {
    for (auto& i : lines) {
      println(handle, i);
    }
  }
  
  void parameters::print(std::ostream& handle, std::list<std::string>& elements, std::string delimiter) {
    std::string d;
    for (auto& i : elements) {
      std::string x = d + i;
      print(handle, x);
      d = delimiter;
    }
  }

  void parameters::AreaContainer::flush(std::ostream& header_file, std::ostream& implementation_file, int hierarchy, bool verbose) {
    println(header_file, top);
    for (auto& i : children) {
      i.flush(header_file, hierarchy, verbose);
    }
    println(header_file, bottom);
    println(implementation_file, implementation_top);
    println(implementation_file, implementation_contents);
  }

  void parameters::ClassContainer::flush(std::ostream& handle, int hierarchy, bool verbose) {
    if (verbose) {
      handle << "// Area Contend (hierarchy = " + std::to_string(hierarchy) + ", active = " + std::string(active ? "true" : "false") + ")" << std::endl;
    }
    /*
      class_description {

        constructor_description : constructor_initilizer_list {
	  constructor_contents
	}
	
	class_contents

	children
	
      }
    */
    print(handle, class_description + " {");
    print(handle, constructor_description);
    print(handle, constructor_initializer_list, ",");
    println(handle, "{");
    println(handle, constructor_contents);
    println(handle, "}");
    println(handle, class_contents);
    for (auto& i : children) {
      i.flush(handle, hierarchy + 1, verbose);
    }
    println(handle, "}");
  }
  
  void parameters::addTop(std::string text) {
    file_container.content.top.push_back(text);
  }

  void parameters::newClass(std::string description) {
    debug.functionStart("newClass(" + description + ")");
    ClassContainer a;
    a.class_description = description;
    ClassContainer* c = file_container.getCurrentClassContainer();
    if (c == NULL) {
      file_container.content.children.push_back(a);
    } else {
      c->children.push_back(a);
    }
    debug.functionEnd("newClass");
  }

  void parameters::setClassConstructorDescription(std::string text) {
    getActiveClassContainer()->constructor_description = text;
  }

  void parameters::addClassConstructorInitializerList(std::string text) {
    getActiveClassContainer()->constructor_initializer_list.push_back(text);
  }

  void parameters::addClassConstructorContents(std::string text) {
    getActiveClassContainer()->constructor_contents.push_back(text);
  }

  void parameters::addClassContents(std::string text) {
    getActiveClassContainer()->class_contents.push_back(text);
  }

  void parameters::endClass() {
    debug.functionStart("endClass");
    getActiveClassContainer()->active = false;
    debug.functionEnd("endClass");
  }
  
  void parameters::addBottom(std::string text) {
    file_container.content.bottom.push_back(text);
  }

  void parameters::addImplementationTop(std::string text) {
    file_container.content.implementation_top.push_back(text);
  }
  
  void parameters::addImplementationContents(std::string text) {
    file_container.content.implementation_contents.push_back(text);
  }

  parameters::ClassContainer* parameters::getCurrentClassContainer() {
    debug.functionStart("getCurrentClassContainer");
    ClassContainer* a = file_container.getCurrentClassContainer();
    debug.functionEnd("getCurrentClassContainer");
    return a;
  }

  parameters::ClassContainer* parameters::getActiveClassContainer() {
    debug.functionStart("getActiveClassContainer");
    ClassContainer* a = getCurrentClassContainer();
    assert(a != NULL);
    debug.functionEnd("getActiveClassContainer");
    return a;
  }

  parameters::ClassContainer* parameters::FileContainer::getCurrentClassContainer() {
    debug.functionStart("getCurrentClassContainer");
    ClassContainer* a = NULL;
    if (!content.children.empty()) {
      ClassContainer& x = content.children.front();
      a = &x;
      int index = 0;
      bool done = false;
      do {
	debug.debug("Index = " + std::to_string(index));
	if (a->children.empty()) {
	  done = true;
	} else {
	  ClassContainer& x = a->children.front();
	  if (x.active) {
	    a = &x;
	  } else {
	    done = true;
	  }
	}
	index++;
      } while (!done);
    }
    debug.functionEnd("getCurrentClassContainer");
    return a;
  }

  bool parameters::isQuiet() {
    return quiet;
  }

  bool parameters::setQuiet(bool quiet) {
    bool q = this->quiet;
    this->quiet = quiet;
    return q;
  }

  void parameters::setPackageName(const std::string& path, const std::string& name) {
    info_writer.SetPackageName(path, name);
  }

  void parameters::printHierarchy() {
    std::cout << "<printHierarchy>" << std::endl;
    file_container.content.flush(std::cout, std::cout, 0, true);
    std::cout << "</printHierarchy>" << std::endl;
  }
  
}
