#!/bin/bash

set -e

SCRIPT=$(realpath $0)
SCRIPTPATH=$(dirname $SCRIPT)

function error {
    local message=$1
    echo "[ERROR] $SCRIPT: $message" 1>&2
}

usage()
{
    cat << EOF
Command: $0 $ALL_ARGUMENTS

usage: $0 options

OPTIONS:
   -h           Show this message
   -f <name>    Filename
   -d <name>    Do filename
   -l <name>    Library name
   -o <name>    VCD output filename
   -x           Debug
   -v           Verbose 
EOF
}

MAX_ERRORS=5

library="work"

while getopts ":hd:f:l:o:vxy" OPTION
do
    case $OPTION in
        h)
            usage
            exit 1
            ;;
        f)
            FILENAME="$OPTARG"
            ;;
        d)
            DO_FILENAME="-d $OPTARG"
            ;;
        l)
            library="$OPTARG"
            ;;
        o)
            VCD_FILENAME="$OPTARG"
            ;;
        v)
            VERBOSE="-v"
	    set -x
            ;;
        x)
            DEBUG="gdb -tui --args"
	    HDLC_DEBUG="-x"
            ;;
        y)
            DEBUG="valgrind -s --leak-check=yes --track-origins=yes --leak-check=full --show-leak-kinds=all"
            ;;
        ?)
            echo "Unknown option $OPTARG"
            usage
            exit 1
            ;;
        :)
            echo "No argument value for option $OPTARG"
            usage
            exit 1
            ;;
    esac
done

if [ -z "$FILENAME" ]; then
    error "Filename must be specified"
    usage
    exit 1
fi

if [ -z "$JHDL" ]; then
    export JHDL=$SCRIPTPATH/../
fi

source $SCRIPTPATH/setup.sh

LINK=""
INCLUDES=""

INCLUDE_DIRS=( kernel/lib output debug exceptions ast ../std ../lib/debug)

for i in ${INCLUDE_DIRS[@]}; do
    SRC=$SCRIPTPATH/$i
    INCLUDES+=" -I${SRC}"
done

OBJECT_DIRS=( output debug exceptions ast ../std ../lib/debug)

for i in ${OBJECT_DIRS[@]}; do
    SRC=$SCRIPTPATH/$i
    if [ ! -e $SRC ]; then
	error "Could not find directory $SRC"
	exit 1
    fi
    OBJECTS+=" ${SRC}/*.o"
done


filebase="${FILENAME%.*}"
headerfile="${library}_$filebase.hpp"
sourcefile="$filebase.cpp"
targetdir=$(dirname $FILENAME)
templatefiles=$(ls $SCRIPTPATH/templates/*.cpp)
TMP_FILE=$(mktemp)
BUILD_PATH=$SCRIPTPATH/build
$BUILD_PATH/hdlf -f $FILENAME -o $TMP_FILE
MODULE_NAME=$(cat $TMP_FILE)
rm $TMP_FILE
if [ -z "$MODULE_NAME" ]; then
    error "Did not find module name in $FILENAME" 
    exit 1
fi
for i in $templatefiles; do
    target=$targetdir/$(basename "$i")
    if [ ! -e $target ]; then
        cp $i $target
	sed -i "s/%module%/${MODULE_NAME}/g" $target
        sed -i "s/%include%/$headerfile/g" $target
    fi
done
cp $SCRIPTPATH/templates/Makefile $targetdir
make -C $targetdir
INCLUDE_FILE=$targetdir/$filebase.i
if [ -e $INCLUDE_FILE ]; then
    INCLUDE_PATHS=$(cat $INCLUDE_FILE)
    for i in $INCLUDE_PATHS; do
	INCLUDES+=" -I$i"
    done
else
    error "Include file $INCLUDE_FILE does not exist. This file must be generated by hdlc."
    exit 1
fi
g++ -std=c++14 -O0 -fconcepts -g -fmax-errors=${MAX_ERRORS} -I$SYSTEMC/include -L$SYSTEMC/lib64 -lsystemc $INCLUDES -o $filebase *.o $OBJECTS
if [ -n "$VCD_FILENAME" ]; then
    if [ ! -e $VCD_FILENAME ]; then
        mkfifo --mode=666 $VCD_FILENAME
    fi
    shmidcat $VCD_FILENAME | gtkwave -v -I output.sav &
    $DEBUG ./$filebase $DO_FILENAME -o $VCD_FILENAME $VERBOSE 
else
    $DEBUG ./$filebase $DO_FILENAME $VERBOSE
fi
