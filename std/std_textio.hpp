#ifndef TEXTIO_VHD_HPP
#define TEXTIO_VHD_HPP
// Autogenerated from source textio.vhd
#include <vhdl.h>
#include <systemc.h>
#include <string.h>
#include "std_standard.hpp"
#include <standard.h>
namespace STD {
// Area Content (name = TEXTIO, hierarchy = 0, active = false)
struct Package_TEXTIO {
Package_TEXTIO() {
}; // constructor TEXTIO end
using LINE = vhdl::vhdl_access<STD::STANDARD::STRING>;
using TEXT = vhdl::vhdl_file<STD::STANDARD::STRING>;
enum class SIDE_enum {RIGHT, LEFT};
struct SIDE_value {
const static int size = 2;
const static int enum_size = 2;
vhdl::EnumerationElement<SIDE_enum> array[size] {{SIDE_enum::RIGHT, 0, "right"}, {SIDE_enum::LEFT, 0, "left"}};
};
using SIDE = vhdl::Enumeration<SIDE_enum, SIDE_value>;
// line 19:     subtype WIDTH is natural;
using WIDTH = STD::STANDARD::NATURAL;
// line 23:     file input : TEXT open READ_MODE is "STD_INPUT";
TEXT INPUT = TEXT(STD::STANDARD::FILE_OPEN_KIND_enum::READ_MODE, "STD_INPUT");
// line 24:     file output : TEXT open WRITE_MODE is "STD_OUTPUT";
TEXT OUTPUT = TEXT(STD::STANDARD::FILE_OPEN_KIND_enum::WRITE_MODE, "STD_OUTPUT");
virtual void READLINE(TEXT& F, LINE& L) = 0;
virtual void READ(LINE& L, STD::STANDARD::BIT& VALUE, STD::STANDARD::BOOLEAN& GOOD) = 0;
virtual void READ(LINE& L, STD::STANDARD::BIT& VALUE) = 0;
virtual void READ(LINE& L, STD::STANDARD::BIT_VECTOR& VALUE, STD::STANDARD::BOOLEAN& GOOD) = 0;
virtual void READ(LINE& L, STD::STANDARD::BIT_VECTOR& VALUE) = 0;
virtual void READ(LINE& L, STD::STANDARD::BOOLEAN& VALUE, STD::STANDARD::BOOLEAN& GOOD) = 0;
virtual void READ(LINE& L, STD::STANDARD::BOOLEAN& VALUE) = 0;
virtual void READ(LINE& L, STD::STANDARD::CHARACTER& VALUE, STD::STANDARD::BOOLEAN& GOOD) = 0;
virtual void READ(LINE& L, STD::STANDARD::CHARACTER& VALUE) = 0;
virtual void READ(LINE& L, STD::STANDARD::INTEGER& VALUE, STD::STANDARD::BOOLEAN& GOOD) = 0;
virtual void READ(LINE& L, STD::STANDARD::INTEGER& VALUE) = 0;
virtual void READ(LINE& L, STD::STANDARD::REAL& VALUE, STD::STANDARD::BOOLEAN& GOOD) = 0;
virtual void READ(LINE& L, STD::STANDARD::REAL& VALUE) = 0;
virtual void READ(LINE& L, STD::STANDARD::STRING& VALUE, STD::STANDARD::BOOLEAN& GOOD) = 0;
virtual void READ(LINE& L, STD::STANDARD::STRING& VALUE) = 0;
virtual void READ(LINE& L, STD::STANDARD::TIME& VALUE, STD::STANDARD::BOOLEAN& GOOD) = 0;
virtual void READ(LINE& L, STD::STANDARD::TIME& VALUE) = 0;
virtual void WRITELINE(TEXT& F, LINE& L) = 0;
virtual void WRITE(LINE& L, STD::STANDARD::BIT VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0) = 0;
virtual void WRITE(LINE& L, STD::STANDARD::BIT_VECTOR VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0) = 0;
virtual void WRITE(LINE& L, STD::STANDARD::BOOLEAN VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0) = 0;
virtual void WRITE(LINE& L, STD::STANDARD::CHARACTER VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0) = 0;
virtual void WRITE(LINE& L, STD::STANDARD::INTEGER VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0) = 0;
virtual void WRITE(LINE& L, STD::STANDARD::REAL VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0, STD::STANDARD::NATURAL DIGITS = 0) = 0;
virtual void WRITE(LINE& L, STD::STANDARD::STRING VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0) = 0;
virtual void WRITE(LINE& L, STD::STANDARD::TIME VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0, STD::STANDARD::TIME UNIT = STD::STANDARD::TIME_enum::NS) = 0;
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_readline(TEXT& F, LINE& L);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read1(LINE& L, STD::STANDARD::BIT& VALUE, STD::STANDARD::BOOLEAN& GOOD);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read2(LINE& L, STD::STANDARD::BIT& VALUE);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read3(LINE& L, STD::STANDARD::BIT_VECTOR& VALUE, STD::STANDARD::BOOLEAN& GOOD);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read4(LINE& L, STD::STANDARD::BIT_VECTOR& VALUE);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read5(LINE& L, STD::STANDARD::BOOLEAN& VALUE, STD::STANDARD::BOOLEAN& GOOD);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read6(LINE& L, STD::STANDARD::BOOLEAN& VALUE);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read7(LINE& L, STD::STANDARD::CHARACTER& VALUE, STD::STANDARD::BOOLEAN& GOOD);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read8(LINE& L, STD::STANDARD::CHARACTER& VALUE);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read9(LINE& L, STD::STANDARD::INTEGER& VALUE, STD::STANDARD::BOOLEAN& GOOD);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read10(LINE& L, STD::STANDARD::INTEGER& VALUE);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read11(LINE& L, STD::STANDARD::REAL& VALUE, STD::STANDARD::BOOLEAN& GOOD);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read12(LINE& L, STD::STANDARD::REAL& VALUE);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read13(LINE& L, STD::STANDARD::STRING& VALUE, STD::STANDARD::BOOLEAN& GOOD);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read14(LINE& L, STD::STANDARD::STRING& VALUE);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read15(LINE& L, STD::STANDARD::TIME& VALUE, STD::STANDARD::BOOLEAN& GOOD);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_read16(LINE& L, STD::STANDARD::TIME& VALUE);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_writeline(TEXT& F, LINE& L);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_write1(LINE& L, STD::STANDARD::BIT VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_write2(LINE& L, STD::STANDARD::BIT_VECTOR VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_write3(LINE& L, STD::STANDARD::BOOLEAN VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_write4(LINE& L, STD::STANDARD::CHARACTER VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_write5(LINE& L, STD::STANDARD::INTEGER VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_write6(LINE& L, STD::STANDARD::REAL VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0, STD::STANDARD::NATURAL DIGITS = 0);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_write7(LINE& L, STD::STANDARD::STRING VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0);
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
void std_textio_write8(LINE& L, STD::STANDARD::TIME VALUE, SIDE JUSTIFIED = SIDE_enum::RIGHT, WIDTH FIELD = 0, STD::STANDARD::TIME UNIT = STD::STANDARD::TIME_enum::NS);
// Area Content (name = LINE, hierarchy = 1, active = false)
struct Factory_LINE {
Factory_LINE(Package_TEXTIO* parent) : p(parent) {
}; // constructor LINE end
Package_TEXTIO* p = NULL; // Used to access parent class.
LINE create() {
LINE x;
return x;
}
template <typename T>
LINE create(T left, T right) {
LINE x(left, right);
return x;
}
}; // class LINE end
// Area Content (name = TEXT, hierarchy = 1, active = false)
struct Factory_TEXT {
Factory_TEXT(Package_TEXTIO* parent) : p(parent) {
}; // constructor TEXT end
Package_TEXTIO* p = NULL; // Used to access parent class.
TEXT create() {
TEXT x;
return x;
}
template <typename T>
TEXT create(T left, T right) {
TEXT x(left, right);
return x;
}
}; // class TEXT end
// Area Content (name = SIDE, hierarchy = 1, active = false)
struct Factory_SIDE {
Factory_SIDE(Package_TEXTIO* parent) : p(parent) {
}; // constructor SIDE end
Package_TEXTIO* p = NULL; // Used to access parent class.
SIDE create() {
SIDE x;
return x;
}
template <typename T>
SIDE create(T left, T right) {
SIDE x(left, right);
return x;
}
}; // class SIDE end
// Area Content (name = WIDTH, hierarchy = 1, active = false)
struct Factory_WIDTH {
Factory_WIDTH(Package_TEXTIO* parent) : p(parent) {
}; // constructor WIDTH end
Package_TEXTIO* p = NULL; // Used to access parent class.
WIDTH create() {
WIDTH x;
return x;
}
template <typename T>
WIDTH create(T left, T right) {
WIDTH x(left, right);
return x;
}
}; // class WIDTH end
Factory_LINE factory_LINE = Factory_LINE(this);
Factory_TEXT factory_TEXT = Factory_TEXT(this);
Factory_SIDE factory_SIDE = Factory_SIDE(this);
Factory_WIDTH factory_WIDTH = Factory_WIDTH(this);
}; // class TEXTIO end
// Area Content (name = TEXTIO, hierarchy = 0, active = false)
struct Package_body_TEXTIO : public Package_TEXTIO {
Package_body_TEXTIO() {
}; // constructor TEXTIO end
void READLINE(STD::TEXTIO::TEXT& F, STD::TEXTIO::LINE& L){
auto inst = Procedure_READLINE_text_line__none(this);
inst.run(F, L);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::BIT& VALUE, STD::STANDARD::BOOLEAN& GOOD){
auto inst = Procedure_READ_line_bit_boolean__none(this);
inst.run(L, VALUE, GOOD);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::BIT& VALUE){
auto inst = Procedure_READ_line_bit__none(this);
inst.run(L, VALUE);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::BIT_VECTOR& VALUE, STD::STANDARD::BOOLEAN& GOOD){
auto inst = Procedure_READ_line_bit_vector_boolean__none(this);
inst.run(L, VALUE, GOOD);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::BIT_VECTOR& VALUE){
auto inst = Procedure_READ_line_bit_vector__none(this);
inst.run(L, VALUE);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::BOOLEAN& VALUE, STD::STANDARD::BOOLEAN& GOOD){
auto inst = Procedure_READ_line_boolean_boolean__none(this);
inst.run(L, VALUE, GOOD);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::BOOLEAN& VALUE){
auto inst = Procedure_READ_line_boolean__none(this);
inst.run(L, VALUE);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::CHARACTER& VALUE, STD::STANDARD::BOOLEAN& GOOD){
auto inst = Procedure_READ_line_character_boolean__none(this);
inst.run(L, VALUE, GOOD);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::CHARACTER& VALUE){
auto inst = Procedure_READ_line_character__none(this);
inst.run(L, VALUE);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::INTEGER& VALUE, STD::STANDARD::BOOLEAN& GOOD){
auto inst = Procedure_READ_line_integer_boolean__none(this);
inst.run(L, VALUE, GOOD);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::INTEGER& VALUE){
auto inst = Procedure_READ_line_integer__none(this);
inst.run(L, VALUE);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::REAL& VALUE, STD::STANDARD::BOOLEAN& GOOD){
auto inst = Procedure_READ_line_real_boolean__none(this);
inst.run(L, VALUE, GOOD);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::REAL& VALUE){
auto inst = Procedure_READ_line_real__none(this);
inst.run(L, VALUE);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::STRING& VALUE, STD::STANDARD::BOOLEAN& GOOD){
auto inst = Procedure_READ_line_string_boolean__none(this);
inst.run(L, VALUE, GOOD);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::STRING& VALUE){
auto inst = Procedure_READ_line_string__none(this);
inst.run(L, VALUE);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::TIME& VALUE, STD::STANDARD::BOOLEAN& GOOD){
auto inst = Procedure_READ_line_time_boolean__none(this);
inst.run(L, VALUE, GOOD);
}
void READ(STD::TEXTIO::LINE& L, STD::STANDARD::TIME& VALUE){
auto inst = Procedure_READ_line_time__none(this);
inst.run(L, VALUE);
}
void WRITELINE(STD::TEXTIO::TEXT& F, STD::TEXTIO::LINE& L){
auto inst = Procedure_WRITELINE_text_line__none(this);
inst.run(F, L);
}
void WRITE(STD::TEXTIO::LINE& L, STD::STANDARD::BIT VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0){
auto inst = Procedure_WRITE_line_bit_side_width__none(this);
inst.run(L, VALUE, JUSTIFIED, FIELD);
}
void WRITE(STD::TEXTIO::LINE& L, STD::STANDARD::BIT_VECTOR VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0){
auto inst = Procedure_WRITE_line_bit_vector_side_width__none(this);
inst.run(L, VALUE, JUSTIFIED, FIELD);
}
void WRITE(STD::TEXTIO::LINE& L, STD::STANDARD::BOOLEAN VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0){
auto inst = Procedure_WRITE_line_boolean_side_width__none(this);
inst.run(L, VALUE, JUSTIFIED, FIELD);
}
void WRITE(STD::TEXTIO::LINE& L, STD::STANDARD::CHARACTER VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0){
auto inst = Procedure_WRITE_line_character_side_width__none(this);
inst.run(L, VALUE, JUSTIFIED, FIELD);
}
void WRITE(STD::TEXTIO::LINE& L, STD::STANDARD::INTEGER VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0){
auto inst = Procedure_WRITE_line_integer_side_width__none(this);
inst.run(L, VALUE, JUSTIFIED, FIELD);
}
void WRITE(STD::TEXTIO::LINE& L, STD::STANDARD::REAL VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0, STD::STANDARD::NATURAL DIGITS = 0){
auto inst = Procedure_WRITE_line_real_side_width_natural__none(this);
inst.run(L, VALUE, JUSTIFIED, FIELD, DIGITS);
}
void WRITE(STD::TEXTIO::LINE& L, STD::STANDARD::STRING VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0){
auto inst = Procedure_WRITE_line_string_side_width__none(this);
inst.run(L, VALUE, JUSTIFIED, FIELD);
}
void WRITE(STD::TEXTIO::LINE& L, STD::STANDARD::TIME VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0, STD::STANDARD::TIME UNIT = STD::STANDARD::TIME_enum::NS){
auto inst = Procedure_WRITE_line_time_side_width_time__none(this);
inst.run(L, VALUE, JUSTIFIED, FIELD, UNIT);
}
// Area Content (name = READLINE_text_line__none, hierarchy = 1, active = false)
struct Procedure_READLINE_text_line__none {
Procedure_READLINE_text_line__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READLINE_text_line__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::TEXT& F, STD::TEXTIO::LINE& L){
// Foreign function call
return p->std_textio_readline(F, L);
}
}; // class READLINE_text_line__none end
// Area Content (name = READ_line_bit_boolean__none, hierarchy = 1, active = false)
struct Procedure_READ_line_bit_boolean__none {
Procedure_READ_line_bit_boolean__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_bit_boolean__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::BIT& VALUE, STD::STANDARD::BOOLEAN& GOOD){
// Foreign function call
return p->std_textio_read1(L, VALUE, GOOD);
}
}; // class READ_line_bit_boolean__none end
// Area Content (name = READ_line_bit__none, hierarchy = 1, active = false)
struct Procedure_READ_line_bit__none {
Procedure_READ_line_bit__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_bit__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::BIT& VALUE){
// Foreign function call
return p->std_textio_read2(L, VALUE);
}
}; // class READ_line_bit__none end
// Area Content (name = READ_line_bit_vector_boolean__none, hierarchy = 1, active = false)
struct Procedure_READ_line_bit_vector_boolean__none {
Procedure_READ_line_bit_vector_boolean__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_bit_vector_boolean__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::BIT_VECTOR& VALUE, STD::STANDARD::BOOLEAN& GOOD){
// Foreign function call
return p->std_textio_read3(L, VALUE, GOOD);
}
}; // class READ_line_bit_vector_boolean__none end
// Area Content (name = READ_line_bit_vector__none, hierarchy = 1, active = false)
struct Procedure_READ_line_bit_vector__none {
Procedure_READ_line_bit_vector__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_bit_vector__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::BIT_VECTOR& VALUE){
// Foreign function call
return p->std_textio_read4(L, VALUE);
}
}; // class READ_line_bit_vector__none end
// Area Content (name = READ_line_boolean_boolean__none, hierarchy = 1, active = false)
struct Procedure_READ_line_boolean_boolean__none {
Procedure_READ_line_boolean_boolean__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_boolean_boolean__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::BOOLEAN& VALUE, STD::STANDARD::BOOLEAN& GOOD){
// Foreign function call
return p->std_textio_read5(L, VALUE, GOOD);
}
}; // class READ_line_boolean_boolean__none end
// Area Content (name = READ_line_boolean__none, hierarchy = 1, active = false)
struct Procedure_READ_line_boolean__none {
Procedure_READ_line_boolean__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_boolean__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::BOOLEAN& VALUE){
// Foreign function call
return p->std_textio_read6(L, VALUE);
}
}; // class READ_line_boolean__none end
// Area Content (name = READ_line_character_boolean__none, hierarchy = 1, active = false)
struct Procedure_READ_line_character_boolean__none {
Procedure_READ_line_character_boolean__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_character_boolean__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::CHARACTER& VALUE, STD::STANDARD::BOOLEAN& GOOD){
// Foreign function call
return p->std_textio_read7(L, VALUE, GOOD);
}
}; // class READ_line_character_boolean__none end
// Area Content (name = READ_line_character__none, hierarchy = 1, active = false)
struct Procedure_READ_line_character__none {
Procedure_READ_line_character__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_character__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::CHARACTER& VALUE){
// Foreign function call
return p->std_textio_read8(L, VALUE);
}
}; // class READ_line_character__none end
// Area Content (name = READ_line_integer_boolean__none, hierarchy = 1, active = false)
struct Procedure_READ_line_integer_boolean__none {
Procedure_READ_line_integer_boolean__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_integer_boolean__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::INTEGER& VALUE, STD::STANDARD::BOOLEAN& GOOD){
// Foreign function call
return p->std_textio_read9(L, VALUE, GOOD);
}
}; // class READ_line_integer_boolean__none end
// Area Content (name = READ_line_integer__none, hierarchy = 1, active = false)
struct Procedure_READ_line_integer__none {
Procedure_READ_line_integer__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_integer__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::INTEGER& VALUE){
// Foreign function call
return p->std_textio_read10(L, VALUE);
}
}; // class READ_line_integer__none end
// Area Content (name = READ_line_real_boolean__none, hierarchy = 1, active = false)
struct Procedure_READ_line_real_boolean__none {
Procedure_READ_line_real_boolean__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_real_boolean__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::REAL& VALUE, STD::STANDARD::BOOLEAN& GOOD){
// Foreign function call
return p->std_textio_read11(L, VALUE, GOOD);
}
}; // class READ_line_real_boolean__none end
// Area Content (name = READ_line_real__none, hierarchy = 1, active = false)
struct Procedure_READ_line_real__none {
Procedure_READ_line_real__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_real__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::REAL& VALUE){
// Foreign function call
return p->std_textio_read12(L, VALUE);
}
}; // class READ_line_real__none end
// Area Content (name = READ_line_string_boolean__none, hierarchy = 1, active = false)
struct Procedure_READ_line_string_boolean__none {
Procedure_READ_line_string_boolean__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_string_boolean__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::STRING& VALUE, STD::STANDARD::BOOLEAN& GOOD){
// Foreign function call
return p->std_textio_read13(L, VALUE, GOOD);
}
}; // class READ_line_string_boolean__none end
// Area Content (name = READ_line_string__none, hierarchy = 1, active = false)
struct Procedure_READ_line_string__none {
Procedure_READ_line_string__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_string__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::STRING& VALUE){
// Foreign function call
return p->std_textio_read14(L, VALUE);
}
}; // class READ_line_string__none end
// Area Content (name = READ_line_time_boolean__none, hierarchy = 1, active = false)
struct Procedure_READ_line_time_boolean__none {
Procedure_READ_line_time_boolean__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_time_boolean__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::TIME& VALUE, STD::STANDARD::BOOLEAN& GOOD){
// Foreign function call
return p->std_textio_read15(L, VALUE, GOOD);
}
}; // class READ_line_time_boolean__none end
// Area Content (name = READ_line_time__none, hierarchy = 1, active = false)
struct Procedure_READ_line_time__none {
Procedure_READ_line_time__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor READ_line_time__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::TIME& VALUE){
// Foreign function call
return p->std_textio_read16(L, VALUE);
}
}; // class READ_line_time__none end
// Area Content (name = WRITELINE_text_line__none, hierarchy = 1, active = false)
struct Procedure_WRITELINE_text_line__none {
Procedure_WRITELINE_text_line__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor WRITELINE_text_line__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::TEXT& F, STD::TEXTIO::LINE& L){
// Foreign function call
return p->std_textio_writeline(F, L);
}
}; // class WRITELINE_text_line__none end
// Area Content (name = WRITE_line_bit_side_width__none, hierarchy = 1, active = false)
struct Procedure_WRITE_line_bit_side_width__none {
Procedure_WRITE_line_bit_side_width__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor WRITE_line_bit_side_width__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::BIT VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0){
// Foreign function call
return p->std_textio_write1(L, VALUE, JUSTIFIED, FIELD);
}
}; // class WRITE_line_bit_side_width__none end
// Area Content (name = WRITE_line_bit_vector_side_width__none, hierarchy = 1, active = false)
struct Procedure_WRITE_line_bit_vector_side_width__none {
Procedure_WRITE_line_bit_vector_side_width__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor WRITE_line_bit_vector_side_width__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::BIT_VECTOR VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0){
// Foreign function call
return p->std_textio_write2(L, VALUE, JUSTIFIED, FIELD);
}
}; // class WRITE_line_bit_vector_side_width__none end
// Area Content (name = WRITE_line_boolean_side_width__none, hierarchy = 1, active = false)
struct Procedure_WRITE_line_boolean_side_width__none {
Procedure_WRITE_line_boolean_side_width__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor WRITE_line_boolean_side_width__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::BOOLEAN VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0){
// Foreign function call
return p->std_textio_write3(L, VALUE, JUSTIFIED, FIELD);
}
}; // class WRITE_line_boolean_side_width__none end
// Area Content (name = WRITE_line_character_side_width__none, hierarchy = 1, active = false)
struct Procedure_WRITE_line_character_side_width__none {
Procedure_WRITE_line_character_side_width__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor WRITE_line_character_side_width__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::CHARACTER VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0){
// Foreign function call
return p->std_textio_write4(L, VALUE, JUSTIFIED, FIELD);
}
}; // class WRITE_line_character_side_width__none end
// Area Content (name = WRITE_line_integer_side_width__none, hierarchy = 1, active = false)
struct Procedure_WRITE_line_integer_side_width__none {
Procedure_WRITE_line_integer_side_width__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor WRITE_line_integer_side_width__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::INTEGER VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0){
// Foreign function call
return p->std_textio_write5(L, VALUE, JUSTIFIED, FIELD);
}
}; // class WRITE_line_integer_side_width__none end
// Area Content (name = WRITE_line_real_side_width_natural__none, hierarchy = 1, active = false)
struct Procedure_WRITE_line_real_side_width_natural__none {
Procedure_WRITE_line_real_side_width_natural__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor WRITE_line_real_side_width_natural__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::REAL VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0, STD::STANDARD::NATURAL DIGITS = 0){
// Foreign function call
return p->std_textio_write6(L, VALUE, JUSTIFIED, FIELD, DIGITS);
}
}; // class WRITE_line_real_side_width_natural__none end
// Area Content (name = WRITE_line_string_side_width__none, hierarchy = 1, active = false)
struct Procedure_WRITE_line_string_side_width__none {
Procedure_WRITE_line_string_side_width__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor WRITE_line_string_side_width__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::STRING VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0){
// Foreign function call
return p->std_textio_write7(L, VALUE, JUSTIFIED, FIELD);
}
}; // class WRITE_line_string_side_width__none end
// Area Content (name = WRITE_line_time_side_width_time__none, hierarchy = 1, active = false)
struct Procedure_WRITE_line_time_side_width_time__none {
Procedure_WRITE_line_time_side_width_time__none(Package_TEXTIO* parent) : p(parent) {
}; // constructor WRITE_line_time_side_width_time__none end
Package_TEXTIO* p = NULL; // Used to access parent class.
void run(STD::TEXTIO::LINE& L, STD::STANDARD::TIME VALUE, STD::TEXTIO::SIDE JUSTIFIED = STD::TEXTIO::SIDE_enum::RIGHT, STD::TEXTIO::WIDTH FIELD = 0, STD::STANDARD::TIME UNIT = STD::STANDARD::TIME_enum::NS){
// Foreign function call
return p->std_textio_write8(L, VALUE, JUSTIFIED, FIELD, UNIT);
}
}; // class WRITE_line_time_side_width_time__none end
}; // class TEXTIO end
using TEXTIO = Package_body_TEXTIO;
} // namespace STD end 
extern STD::TEXTIO STD_TEXTIO;
#endif
