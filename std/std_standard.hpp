#ifndef STANDARD_VHD_HPP
#define STANDARD_VHD_HPP
// Autogenerated from source standard.vhd
#include <vhdl.h>
#include <systemc.h>
#include <string.h>
namespace STD {
// Area Content (name = STANDARD, hierarchy = 0, active = false)
struct Package_STANDARD {
Package_STANDARD() {
}; // constructor STANDARD end
enum class BOOLEAN_enum {FALSE, TRUE};
struct BOOLEAN_value {
const static int size = 2;
const static int enum_size = 2;
vhdl::EnumerationElement<BOOLEAN_enum> array[size] {{BOOLEAN_enum::FALSE, 0, "FALSE"}, {BOOLEAN_enum::TRUE, 0, "TRUE"}};
};
using BOOLEAN = vhdl::Enumeration<BOOLEAN_enum, BOOLEAN_value>;
enum class BIT_enum {};
struct BIT_value {
const static int size = 2;
const static int enum_size = 0;
vhdl::EnumerationElement<BIT_enum> array[size] {{(BIT_enum)0, '0', ""}, {(BIT_enum)0, '1', ""}};
};
using BIT = vhdl::Enumeration<BIT_enum, BIT_value>;
enum class CHARACTER_enum {NUL, SOH, STX, ETX, EOT, ENQ, ACK, BEL, BS, HT, LF, VT, FF, CR, SO, SI, DLE, DC1, DC2, DC3, DC4, NAK, SYN, ETB, CAN, EM, SUB, ESC, FSP, GSP, RSP, USP, DEL, C128, C129, C130, C131, C132, C133, C134, C135, C136, C137, C138, C139, C140, C141, C142, C143, C144, C145, C146, C147, C148, C149, C150, C151, C152, C153, C154, C155, C156, C157, C158, C159};
struct CHARACTER_value {
const static int size = 256;
const static int enum_size = 65;
vhdl::EnumerationElement<CHARACTER_enum> array[size] {{CHARACTER_enum::NUL, 0, "NUL"}, {CHARACTER_enum::SOH, 0, "SOH"}, {CHARACTER_enum::STX, 0, "STX"}, {CHARACTER_enum::ETX, 0, "ETX"}, {CHARACTER_enum::EOT, 0, "EOT"}, {CHARACTER_enum::ENQ, 0, "ENQ"}, {CHARACTER_enum::ACK, 0, "ACK"}, {CHARACTER_enum::BEL, 0, "BEL"}, {CHARACTER_enum::BS, 0, "BS"}, {CHARACTER_enum::HT, 0, "HT"}, {CHARACTER_enum::LF, 0, "LF"}, {CHARACTER_enum::VT, 0, "VT"}, {CHARACTER_enum::FF, 0, "FF"}, {CHARACTER_enum::CR, 0, "CR"}, {CHARACTER_enum::SO, 0, "SO"}, {CHARACTER_enum::SI, 0, "SI"}, {CHARACTER_enum::DLE, 0, "DLE"}, {CHARACTER_enum::DC1, 0, "DC1"}, {CHARACTER_enum::DC2, 0, "DC2"}, {CHARACTER_enum::DC3, 0, "DC3"}, {CHARACTER_enum::DC4, 0, "DC4"}, {CHARACTER_enum::NAK, 0, "NAK"}, {CHARACTER_enum::SYN, 0, "SYN"}, {CHARACTER_enum::ETB, 0, "ETB"}, {CHARACTER_enum::CAN, 0, "CAN"}, {CHARACTER_enum::EM, 0, "EM"}, {CHARACTER_enum::SUB, 0, "SUB"}, {CHARACTER_enum::ESC, 0, "ESC"}, {CHARACTER_enum::FSP, 0, "FSP"}, {CHARACTER_enum::GSP, 0, "GSP"}, {CHARACTER_enum::RSP, 0, "RSP"}, {CHARACTER_enum::USP, 0, "USP"}, {(CHARACTER_enum)0, ' ', ""}, {(CHARACTER_enum)0, '!', ""}, {(CHARACTER_enum)0, '"', ""}, {(CHARACTER_enum)0, '#', ""}, {(CHARACTER_enum)0, '$', ""}, {(CHARACTER_enum)0, '%', ""}, {(CHARACTER_enum)0, '&', ""}, {(CHARACTER_enum)0, '\'', ""}, {(CHARACTER_enum)0, '(', ""}, {(CHARACTER_enum)0, ')', ""}, {(CHARACTER_enum)0, '*', ""}, {(CHARACTER_enum)0, '+', ""}, {(CHARACTER_enum)0, ',', ""}, {(CHARACTER_enum)0, '-', ""}, {(CHARACTER_enum)0, '.', ""}, {(CHARACTER_enum)0, '/', ""}, {(CHARACTER_enum)0, '0', ""}, {(CHARACTER_enum)0, '1', ""}, {(CHARACTER_enum)0, '2', ""}, {(CHARACTER_enum)0, '3', ""}, {(CHARACTER_enum)0, '4', ""}, {(CHARACTER_enum)0, '5', ""}, {(CHARACTER_enum)0, '6', ""}, {(CHARACTER_enum)0, '7', ""}, {(CHARACTER_enum)0, '8', ""}, {(CHARACTER_enum)0, '9', ""}, {(CHARACTER_enum)0, ':', ""}, {(CHARACTER_enum)0, ';', ""}, {(CHARACTER_enum)0, '<', ""}, {(CHARACTER_enum)0, '=', ""}, {(CHARACTER_enum)0, '>', ""}, {(CHARACTER_enum)0, '?', ""}, {(CHARACTER_enum)0, '@', ""}, {(CHARACTER_enum)0, 'A', ""}, {(CHARACTER_enum)0, 'B', ""}, {(CHARACTER_enum)0, 'C', ""}, {(CHARACTER_enum)0, 'D', ""}, {(CHARACTER_enum)0, 'E', ""}, {(CHARACTER_enum)0, 'F', ""}, {(CHARACTER_enum)0, 'G', ""}, {(CHARACTER_enum)0, 'H', ""}, {(CHARACTER_enum)0, 'I', ""}, {(CHARACTER_enum)0, 'J', ""}, {(CHARACTER_enum)0, 'K', ""}, {(CHARACTER_enum)0, 'L', ""}, {(CHARACTER_enum)0, 'M', ""}, {(CHARACTER_enum)0, 'N', ""}, {(CHARACTER_enum)0, 'O', ""}, {(CHARACTER_enum)0, 'P', ""}, {(CHARACTER_enum)0, 'Q', ""}, {(CHARACTER_enum)0, 'R', ""}, {(CHARACTER_enum)0, 'S', ""}, {(CHARACTER_enum)0, 'T', ""}, {(CHARACTER_enum)0, 'U', ""}, {(CHARACTER_enum)0, 'V', ""}, {(CHARACTER_enum)0, 'W', ""}, {(CHARACTER_enum)0, 'X', ""}, {(CHARACTER_enum)0, 'Y', ""}, {(CHARACTER_enum)0, 'Z', ""}, {(CHARACTER_enum)0, '[', ""}, {(CHARACTER_enum)0, '\\', ""}, {(CHARACTER_enum)0, ']', ""}, {(CHARACTER_enum)0, '^', ""}, {(CHARACTER_enum)0, '_', ""}, {(CHARACTER_enum)0, '`', ""}, {(CHARACTER_enum)0, 'a', ""}, {(CHARACTER_enum)0, 'b', ""}, {(CHARACTER_enum)0, 'c', ""}, {(CHARACTER_enum)0, 'd', ""}, {(CHARACTER_enum)0, 'e', ""}, {(CHARACTER_enum)0, 'f', ""}, {(CHARACTER_enum)0, 'g', ""}, {(CHARACTER_enum)0, 'h', ""}, {(CHARACTER_enum)0, 'i', ""}, {(CHARACTER_enum)0, 'j', ""}, {(CHARACTER_enum)0, 'k', ""}, {(CHARACTER_enum)0, 'l', ""}, {(CHARACTER_enum)0, 'm', ""}, {(CHARACTER_enum)0, 'n', ""}, {(CHARACTER_enum)0, 'o', ""}, {(CHARACTER_enum)0, 'p', ""}, {(CHARACTER_enum)0, 'q', ""}, {(CHARACTER_enum)0, 'r', ""}, {(CHARACTER_enum)0, 's', ""}, {(CHARACTER_enum)0, 't', ""}, {(CHARACTER_enum)0, 'u', ""}, {(CHARACTER_enum)0, 'v', ""}, {(CHARACTER_enum)0, 'w', ""}, {(CHARACTER_enum)0, 'x', ""}, {(CHARACTER_enum)0, 'y', ""}, {(CHARACTER_enum)0, 'z', ""}, {(CHARACTER_enum)0, '{', ""}, {(CHARACTER_enum)0, '|', ""}, {(CHARACTER_enum)0, '}', ""}, {(CHARACTER_enum)0, '~', ""}, {CHARACTER_enum::DEL, 0, "DEL"}, {CHARACTER_enum::C128, 0, "C128"}, {CHARACTER_enum::C129, 0, "C129"}, {CHARACTER_enum::C130, 0, "C130"}, {CHARACTER_enum::C131, 0, "C131"}, {CHARACTER_enum::C132, 0, "C132"}, {CHARACTER_enum::C133, 0, "C133"}, {CHARACTER_enum::C134, 0, "C134"}, {CHARACTER_enum::C135, 0, "C135"}, {CHARACTER_enum::C136, 0, "C136"}, {CHARACTER_enum::C137, 0, "C137"}, {CHARACTER_enum::C138, 0, "C138"}, {CHARACTER_enum::C139, 0, "C139"}, {CHARACTER_enum::C140, 0, "C140"}, {CHARACTER_enum::C141, 0, "C141"}, {CHARACTER_enum::C142, 0, "C142"}, {CHARACTER_enum::C143, 0, "C143"}, {CHARACTER_enum::C144, 0, "C144"}, {CHARACTER_enum::C145, 0, "C145"}, {CHARACTER_enum::C146, 0, "C146"}, {CHARACTER_enum::C147, 0, "C147"}, {CHARACTER_enum::C148, 0, "C148"}, {CHARACTER_enum::C149, 0, "C149"}, {CHARACTER_enum::C150, 0, "C150"}, {CHARACTER_enum::C151, 0, "C151"}, {CHARACTER_enum::C152, 0, "C152"}, {CHARACTER_enum::C153, 0, "C153"}, {CHARACTER_enum::C154, 0, "C154"}, {CHARACTER_enum::C155, 0, "C155"}, {CHARACTER_enum::C156, 0, "C156"}, {CHARACTER_enum::C157, 0, "C157"}, {CHARACTER_enum::C158, 0, "C158"}, {CHARACTER_enum::C159, 0, "C159"}, {(CHARACTER_enum)0, ' ', ""}, {(CHARACTER_enum)0, '¡', ""}, {(CHARACTER_enum)0, '¢', ""}, {(CHARACTER_enum)0, '£', ""}, {(CHARACTER_enum)0, '¤', ""}, {(CHARACTER_enum)0, '¥', ""}, {(CHARACTER_enum)0, '¦', ""}, {(CHARACTER_enum)0, '§', ""}, {(CHARACTER_enum)0, '¨', ""}, {(CHARACTER_enum)0, '©', ""}, {(CHARACTER_enum)0, 'ª', ""}, {(CHARACTER_enum)0, '«', ""}, {(CHARACTER_enum)0, '¬', ""}, {(CHARACTER_enum)0, '­', ""}, {(CHARACTER_enum)0, '®', ""}, {(CHARACTER_enum)0, '¯', ""}, {(CHARACTER_enum)0, '°', ""}, {(CHARACTER_enum)0, '±', ""}, {(CHARACTER_enum)0, '²', ""}, {(CHARACTER_enum)0, '³', ""}, {(CHARACTER_enum)0, '´', ""}, {(CHARACTER_enum)0, 'µ', ""}, {(CHARACTER_enum)0, '¶', ""}, {(CHARACTER_enum)0, '·', ""}, {(CHARACTER_enum)0, '¸', ""}, {(CHARACTER_enum)0, '¹', ""}, {(CHARACTER_enum)0, 'º', ""}, {(CHARACTER_enum)0, '»', ""}, {(CHARACTER_enum)0, '¼', ""}, {(CHARACTER_enum)0, '½', ""}, {(CHARACTER_enum)0, '¾', ""}, {(CHARACTER_enum)0, '¿', ""}, {(CHARACTER_enum)0, 'À', ""}, {(CHARACTER_enum)0, 'Á', ""}, {(CHARACTER_enum)0, 'Â', ""}, {(CHARACTER_enum)0, 'Ã', ""}, {(CHARACTER_enum)0, 'Ä', ""}, {(CHARACTER_enum)0, 'Å', ""}, {(CHARACTER_enum)0, 'Æ', ""}, {(CHARACTER_enum)0, 'Ç', ""}, {(CHARACTER_enum)0, 'È', ""}, {(CHARACTER_enum)0, 'É', ""}, {(CHARACTER_enum)0, 'Ê', ""}, {(CHARACTER_enum)0, 'Ë', ""}, {(CHARACTER_enum)0, 'Ì', ""}, {(CHARACTER_enum)0, 'Í', ""}, {(CHARACTER_enum)0, 'Î', ""}, {(CHARACTER_enum)0, 'Ï', ""}, {(CHARACTER_enum)0, 'Ð', ""}, {(CHARACTER_enum)0, 'Ñ', ""}, {(CHARACTER_enum)0, 'Ò', ""}, {(CHARACTER_enum)0, 'Ó', ""}, {(CHARACTER_enum)0, 'Ô', ""}, {(CHARACTER_enum)0, 'Õ', ""}, {(CHARACTER_enum)0, 'Ö', ""}, {(CHARACTER_enum)0, '×', ""}, {(CHARACTER_enum)0, 'Ø', ""}, {(CHARACTER_enum)0, 'Ù', ""}, {(CHARACTER_enum)0, 'Ú', ""}, {(CHARACTER_enum)0, 'Û', ""}, {(CHARACTER_enum)0, 'Ü', ""}, {(CHARACTER_enum)0, 'Ý', ""}, {(CHARACTER_enum)0, 'Þ', ""}, {(CHARACTER_enum)0, 'ß', ""}, {(CHARACTER_enum)0, 'à', ""}, {(CHARACTER_enum)0, 'á', ""}, {(CHARACTER_enum)0, 'â', ""}, {(CHARACTER_enum)0, 'ã', ""}, {(CHARACTER_enum)0, 'ä', ""}, {(CHARACTER_enum)0, 'å', ""}, {(CHARACTER_enum)0, 'æ', ""}, {(CHARACTER_enum)0, 'ç', ""}, {(CHARACTER_enum)0, 'è', ""}, {(CHARACTER_enum)0, 'é', ""}, {(CHARACTER_enum)0, 'ê', ""}, {(CHARACTER_enum)0, 'ë', ""}, {(CHARACTER_enum)0, 'ì', ""}, {(CHARACTER_enum)0, 'í', ""}, {(CHARACTER_enum)0, 'î', ""}, {(CHARACTER_enum)0, 'ï', ""}, {(CHARACTER_enum)0, 'ð', ""}, {(CHARACTER_enum)0, 'ñ', ""}, {(CHARACTER_enum)0, 'ò', ""}, {(CHARACTER_enum)0, 'ó', ""}, {(CHARACTER_enum)0, 'ô', ""}, {(CHARACTER_enum)0, 'õ', ""}, {(CHARACTER_enum)0, 'ö', ""}, {(CHARACTER_enum)0, '÷', ""}, {(CHARACTER_enum)0, 'ø', ""}, {(CHARACTER_enum)0, 'ù', ""}, {(CHARACTER_enum)0, 'ú', ""}, {(CHARACTER_enum)0, 'û', ""}, {(CHARACTER_enum)0, 'ü', ""}, {(CHARACTER_enum)0, 'ý', ""}, {(CHARACTER_enum)0, 'þ', ""}, {(CHARACTER_enum)0, 'ÿ', ""}};
};
using CHARACTER = vhdl::Enumeration<CHARACTER_enum, CHARACTER_value>;
enum class SEVERITY_LEVEL_enum {NOTE, WARNING, ERROR, FAILURE};
struct SEVERITY_LEVEL_value {
const static int size = 4;
const static int enum_size = 4;
vhdl::EnumerationElement<SEVERITY_LEVEL_enum> array[size] {{SEVERITY_LEVEL_enum::NOTE, 0, "NOTE"}, {SEVERITY_LEVEL_enum::WARNING, 0, "WARNING"}, {SEVERITY_LEVEL_enum::ERROR, 0, "ERROR"}, {SEVERITY_LEVEL_enum::FAILURE, 0, "FAILURE"}};
};
using SEVERITY_LEVEL = vhdl::Enumeration<SEVERITY_LEVEL_enum, SEVERITY_LEVEL_value>;
enum class FILE_OPEN_KIND_enum {READ_MODE, WRITE_MODE, APPEND_MODE};
struct FILE_OPEN_KIND_value {
const static int size = 3;
const static int enum_size = 3;
vhdl::EnumerationElement<FILE_OPEN_KIND_enum> array[size] {{FILE_OPEN_KIND_enum::READ_MODE, 0, "READ_MODE"}, {FILE_OPEN_KIND_enum::WRITE_MODE, 0, "WRITE_MODE"}, {FILE_OPEN_KIND_enum::APPEND_MODE, 0, "APPEND_MODE"}};
};
using FILE_OPEN_KIND = vhdl::Enumeration<FILE_OPEN_KIND_enum, FILE_OPEN_KIND_value>;
enum class FILE_OPEN_STATUS_enum {OPEN_OK, STATUS_ERROR, NAME_ERROR, MODE_ERROR};
struct FILE_OPEN_STATUS_value {
const static int size = 4;
const static int enum_size = 4;
vhdl::EnumerationElement<FILE_OPEN_STATUS_enum> array[size] {{FILE_OPEN_STATUS_enum::OPEN_OK, 0, "OPEN_OK"}, {FILE_OPEN_STATUS_enum::STATUS_ERROR, 0, "STATUS_ERROR"}, {FILE_OPEN_STATUS_enum::NAME_ERROR, 0, "NAME_ERROR"}, {FILE_OPEN_STATUS_enum::MODE_ERROR, 0, "MODE_ERROR"}};
};
using FILE_OPEN_STATUS = vhdl::Enumeration<FILE_OPEN_STATUS_enum, FILE_OPEN_STATUS_value>;
using INTEGER = vhdl::Range<decltype(-2147483647)>;
using REAL = vhdl::Range<decltype(-1.7014111e+308)>;
enum TIME_enum {FS, PS, NS, US, MS, SEC, MIN, HR};
struct TIME_unit {
std::string toString(TIME_enum e) {
static std::string translate[8] = {"fs", "ps", "ns", "us", "ms", "sec", "min", "hr"};
return translate[e];
}
};
struct TIME_value {
const int size = 8;
const vhdl::PhysicalElement<TIME_enum, decltype(-2147483647)> array[8] {{FS, 1, FS}, {PS, 1000, FS}, {NS, 1000, PS}, {US, 1000, NS}, {MS, 1000, US}, {SEC, 1000, MS}, {MIN, 60, SEC}, {HR, 60, MIN}};
};
using TIME_type = vhdl::Physical<decltype(-2147483647), TIME_enum>;
using TIME = vhdl::PhysicalType<decltype(-2147483647), TIME_enum, TIME_value, TIME_unit>;
// line 76:   subtype DELAY_LENGTH is TIME range 0 fs to TIME'HIGH;
using DELAY_LENGTH = TIME;
virtual DELAY_LENGTH NOW() = 0;
/*
 * This is the definition of the foreign function set as an attribute.
 * The implementation must be defined in a .cpp file in this directory.
*/
DELAY_LENGTH vhdl_now();
// line 86:   subtype NATURAL is INTEGER range 0 to INTEGER'HIGH;
using NATURAL = INTEGER;
// line 88:   subtype POSITIVE is INTEGER range 1 to INTEGER'HIGH;
using POSITIVE = INTEGER;
using STRING = vhdl::Array<POSITIVE, CHARACTER>;
using BIT_VECTOR = vhdl::Array<NATURAL, BIT>;
// Area Content (name = BOOLEAN, hierarchy = 1, active = false)
struct Factory_BOOLEAN {
Factory_BOOLEAN(Package_STANDARD* parent) : p(parent) {
}; // constructor BOOLEAN end
Package_STANDARD* p = NULL; // Used to access parent class.
BOOLEAN create() {
BOOLEAN x;
return x;
}
template <typename T>
BOOLEAN create(T left, T right) {
BOOLEAN x(left, right);
return x;
}
}; // class BOOLEAN end
// Area Content (name = BIT, hierarchy = 1, active = false)
struct Factory_BIT {
Factory_BIT(Package_STANDARD* parent) : p(parent) {
}; // constructor BIT end
Package_STANDARD* p = NULL; // Used to access parent class.
BIT create() {
BIT x;
return x;
}
template <typename T>
BIT create(T left, T right) {
BIT x(left, right);
return x;
}
}; // class BIT end
// Area Content (name = CHARACTER, hierarchy = 1, active = false)
struct Factory_CHARACTER {
Factory_CHARACTER(Package_STANDARD* parent) : p(parent) {
}; // constructor CHARACTER end
Package_STANDARD* p = NULL; // Used to access parent class.
CHARACTER create() {
CHARACTER x;
return x;
}
template <typename T>
CHARACTER create(T left, T right) {
CHARACTER x(left, right);
return x;
}
}; // class CHARACTER end
// Area Content (name = SEVERITY_LEVEL, hierarchy = 1, active = false)
struct Factory_SEVERITY_LEVEL {
Factory_SEVERITY_LEVEL(Package_STANDARD* parent) : p(parent) {
}; // constructor SEVERITY_LEVEL end
Package_STANDARD* p = NULL; // Used to access parent class.
SEVERITY_LEVEL create() {
SEVERITY_LEVEL x;
return x;
}
template <typename T>
SEVERITY_LEVEL create(T left, T right) {
SEVERITY_LEVEL x(left, right);
return x;
}
}; // class SEVERITY_LEVEL end
// Area Content (name = FILE_OPEN_KIND, hierarchy = 1, active = false)
struct Factory_FILE_OPEN_KIND {
Factory_FILE_OPEN_KIND(Package_STANDARD* parent) : p(parent) {
}; // constructor FILE_OPEN_KIND end
Package_STANDARD* p = NULL; // Used to access parent class.
FILE_OPEN_KIND create() {
FILE_OPEN_KIND x;
return x;
}
template <typename T>
FILE_OPEN_KIND create(T left, T right) {
FILE_OPEN_KIND x(left, right);
return x;
}
}; // class FILE_OPEN_KIND end
// Area Content (name = FILE_OPEN_STATUS, hierarchy = 1, active = false)
struct Factory_FILE_OPEN_STATUS {
Factory_FILE_OPEN_STATUS(Package_STANDARD* parent) : p(parent) {
}; // constructor FILE_OPEN_STATUS end
Package_STANDARD* p = NULL; // Used to access parent class.
FILE_OPEN_STATUS create() {
FILE_OPEN_STATUS x;
return x;
}
template <typename T>
FILE_OPEN_STATUS create(T left, T right) {
FILE_OPEN_STATUS x(left, right);
return x;
}
}; // class FILE_OPEN_STATUS end
// Area Content (name = INTEGER, hierarchy = 1, active = false)
struct Factory_INTEGER {
Factory_INTEGER(Package_STANDARD* parent) : p(parent) {
}; // constructor INTEGER end
Package_STANDARD* p = NULL; // Used to access parent class.
INTEGER create() {
INTEGER x(-2147483647, 2147483647);
return x;
}
template <typename T>
INTEGER create(T left, T right) {
INTEGER x(left, right);
return x;
}
}; // class INTEGER end
// Area Content (name = REAL, hierarchy = 1, active = false)
struct Factory_REAL {
Factory_REAL(Package_STANDARD* parent) : p(parent) {
}; // constructor REAL end
Package_STANDARD* p = NULL; // Used to access parent class.
REAL create() {
REAL x(-1.7014111e+308, 1.7014111e+308);
return x;
}
template <typename T>
REAL create(T left, T right) {
REAL x(left, right);
return x;
}
}; // class REAL end
// Area Content (name = TIME, hierarchy = 1, active = false)
struct Factory_TIME {
Factory_TIME(Package_STANDARD* parent) : p(parent) {
}; // constructor TIME end
Package_STANDARD* p = NULL; // Used to access parent class.
TIME create() {
TIME x({-2147483647, FS}, {2147483647, HR});
return x;
}
template <typename T>
TIME create(T left, T right) {
TIME x(left, right);
return x;
}
}; // class TIME end
// Area Content (name = DELAY_LENGTH, hierarchy = 1, active = false)
struct Factory_DELAY_LENGTH {
Factory_DELAY_LENGTH(Package_STANDARD* parent) : p(parent) {
}; // constructor DELAY_LENGTH end
Package_STANDARD* p = NULL; // Used to access parent class.
DELAY_LENGTH create() {
DELAY_LENGTH x({0, TIME_enum::FS}, factory_TIME.create().HIGH());
return x;
}
template <typename T>
DELAY_LENGTH create(T left, T right) {
DELAY_LENGTH x(left, right);
return x;
}
}; // class DELAY_LENGTH end
// Area Content (name = NATURAL, hierarchy = 1, active = false)
struct Factory_NATURAL {
Factory_NATURAL(Package_STANDARD* parent) : p(parent) {
}; // constructor NATURAL end
Package_STANDARD* p = NULL; // Used to access parent class.
NATURAL create() {
NATURAL x(0, factory_INTEGER.create().HIGH());
return x;
}
template <typename T>
NATURAL create(T left, T right) {
NATURAL x(left, right);
return x;
}
}; // class NATURAL end
// Area Content (name = POSITIVE, hierarchy = 1, active = false)
struct Factory_POSITIVE {
Factory_POSITIVE(Package_STANDARD* parent) : p(parent) {
}; // constructor POSITIVE end
Package_STANDARD* p = NULL; // Used to access parent class.
POSITIVE create() {
POSITIVE x(1, factory_INTEGER.create().HIGH());
return x;
}
template <typename T>
POSITIVE create(T left, T right) {
POSITIVE x(left, right);
return x;
}
}; // class POSITIVE end
// Area Content (name = STRING, hierarchy = 1, active = false)
struct Factory_STRING {
Factory_STRING(Package_STANDARD* parent) : p(parent) {
}; // constructor STRING end
Package_STANDARD* p = NULL; // Used to access parent class.
STRING create() {
STRING x;
return x;
}
template <typename T>
STRING create(T left, T right) {
STRING x(left, right);
return x;
}
}; // class STRING end
// Area Content (name = BIT_VECTOR, hierarchy = 1, active = false)
struct Factory_BIT_VECTOR {
Factory_BIT_VECTOR(Package_STANDARD* parent) : p(parent) {
}; // constructor BIT_VECTOR end
Package_STANDARD* p = NULL; // Used to access parent class.
BIT_VECTOR create() {
BIT_VECTOR x;
return x;
}
template <typename T>
BIT_VECTOR create(T left, T right) {
BIT_VECTOR x(left, right);
return x;
}
}; // class BIT_VECTOR end
Factory_BOOLEAN factory_BOOLEAN = Factory_BOOLEAN(this);
Factory_BIT factory_BIT = Factory_BIT(this);
Factory_CHARACTER factory_CHARACTER = Factory_CHARACTER(this);
Factory_SEVERITY_LEVEL factory_SEVERITY_LEVEL = Factory_SEVERITY_LEVEL(this);
Factory_FILE_OPEN_KIND factory_FILE_OPEN_KIND = Factory_FILE_OPEN_KIND(this);
Factory_FILE_OPEN_STATUS factory_FILE_OPEN_STATUS = Factory_FILE_OPEN_STATUS(this);
Factory_INTEGER factory_INTEGER = Factory_INTEGER(this);
Factory_REAL factory_REAL = Factory_REAL(this);
Factory_TIME factory_TIME = Factory_TIME(this);
Factory_DELAY_LENGTH factory_DELAY_LENGTH = Factory_DELAY_LENGTH(this);
Factory_NATURAL factory_NATURAL = Factory_NATURAL(this);
Factory_POSITIVE factory_POSITIVE = Factory_POSITIVE(this);
Factory_STRING factory_STRING = Factory_STRING(this);
Factory_BIT_VECTOR factory_BIT_VECTOR = Factory_BIT_VECTOR(this);
}; // class STANDARD end
// Area Content (name = STANDARD, hierarchy = 0, active = false)
struct Package_body_STANDARD : public Package_STANDARD {
Package_body_STANDARD() {
}; // constructor STANDARD end
STD::STANDARD::DELAY_LENGTH NOW(){
auto inst = Function_NOW__physical(this);
return inst.run();
}
// Area Content (name = NOW__physical, hierarchy = 1, active = false)
struct Function_NOW__physical {
Function_NOW__physical(Package_STANDARD* parent) : p(parent) {
}; // constructor NOW__physical end
Package_STANDARD* p = NULL; // Used to access parent class.
STD::STANDARD::DELAY_LENGTH run(){
// Foreign function call
return p->vhdl_now();
}
}; // class NOW__physical end
}; // class STANDARD end
using STANDARD = Package_body_STANDARD;
} // namespace STD end 
extern STD::STANDARD STD_STANDARD;
#endif
